import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { createClient } from "@supabase/supabase-js";

// Create Supabase client for server-side operations
function getSupabaseClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error("Missing Supabase environment variables");
  }

  return createClient(supabaseUrl, supabaseServiceKey);
}

/**
 * Tool to create and store a health insight generated by AI.
 * Health insights are personalized recommendations based on user's health profile.
 */
export const createHealthInsightTool = createTool({
  id: "create-health-insight",
  description:
    "Stores an AI-generated health insight or recommendation for the user. Use this to save health advice for later reference.",
  inputSchema: z.object({
    userId: z.string().describe("The user's unique identifier"),
    type: z
      .enum(["recommendation", "warning", "observation", "tip"])
      .describe("Type of health insight"),
    title: z.string().describe("Brief title for the insight"),
    content: z.string().describe("Full content of the health insight"),
    category: z
      .enum([
        "nutrition",
        "exercise",
        "sleep",
        "mental_health",
        "hydration",
        "sun_exposure",
        "medication",
        "general",
      ])
      .describe("Category of the health insight"),
    priority: z
      .enum(["high", "medium", "low"])
      .default("medium")
      .describe("Priority level of the insight"),
    relatedToAllergy: z
      .string()
      .optional()
      .describe("If related to a specific allergy"),
    expiresAt: z
      .string()
      .optional()
      .describe("When this insight expires (ISO date)"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    insightId: z.string().optional(),
    error: z.string().optional(),
  }),
  execute: async ({
    userId,
    type,
    title,
    content,
    category,
    priority,
    relatedToAllergy,
    expiresAt,
  }) => {
    try {
      const supabase = getSupabaseClient();

      const { data, error } = await supabase
        .from("health_insights")
        .insert({
          user_id: userId,
          type,
          title,
          content,
          category,
          priority,
          related_to_allergy: relatedToAllergy || null,
          expires_at: expiresAt || null,
        })
        .select("id")
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true, insightId: data.id };
    } catch (err) {
      return {
        success: false,
        error:
          err instanceof Error ? err.message : "Failed to create health insight",
      };
    }
  },
});

/**
 * Tool to get user's health insights history.
 */
export const getHealthInsightsTool = createTool({
  id: "get-health-insights",
  description:
    "Fetches the user's health insights history with optional filtering.",
  inputSchema: z.object({
    userId: z.string().describe("The user's unique identifier"),
    category: z
      .enum([
        "nutrition",
        "exercise",
        "sleep",
        "mental_health",
        "hydration",
        "sun_exposure",
        "medication",
        "general",
      ])
      .optional()
      .describe("Filter by category"),
    limit: z
      .number()
      .default(10)
      .describe("Maximum number of insights to return"),
    includeExpired: z
      .boolean()
      .default(false)
      .describe("Whether to include expired insights"),
  }),
  outputSchema: z.object({
    insights: z.array(
      z.object({
        id: z.string(),
        type: z.string(),
        title: z.string(),
        content: z.string(),
        category: z.string(),
        priority: z.string(),
        createdAt: z.string(),
        expiresAt: z.string().nullable(),
      })
    ),
    error: z.string().optional(),
  }),
  execute: async ({ userId, category, limit, includeExpired }) => {
    try {
      const supabase = getSupabaseClient();

      let query = supabase
        .from("health_insights")
        .select("*")
        .eq("user_id", userId)
        .order("created_at", { ascending: false })
        .limit(limit);

      if (category) {
        query = query.eq("category", category);
      }

      if (!includeExpired) {
        query = query.or(
          `expires_at.is.null,expires_at.gt.${new Date().toISOString()}`
        );
      }

      const { data, error } = await query;

      if (error) {
        return { insights: [], error: error.message };
      }

      return {
        insights: (data || []).map((insight) => ({
          id: insight.id,
          type: insight.type,
          title: insight.title,
          content: insight.content,
          category: insight.category,
          priority: insight.priority,
          createdAt: insight.created_at,
          expiresAt: insight.expires_at,
        })),
      };
    } catch (err) {
      return {
        insights: [],
        error:
          err instanceof Error ? err.message : "Failed to fetch health insights",
      };
    }
  },
});

/**
 * Tool to get current environment data (UV, weather, air quality) for the user's location.
 * This data is fetched from the environment_data table which is populated by a Supabase Edge Function.
 */
export const getEnvironmentDataTool = createTool({
  id: "get-environment-data",
  description:
    "Fetches the latest environmental data (UV index, weather, air quality) for the user's location. Use this for sun exposure advice based on skin tone.",
  inputSchema: z.object({
    userId: z.string().describe("The user's unique identifier"),
  }),
  outputSchema: z.object({
    hasData: z.boolean(),
    data: z
      .object({
        city: z.string().nullable(),
        uvIndex: z.number().nullable(),
        weatherCondition: z.string().nullable(),
        temperature: z.number().nullable(),
        airQualityIndex: z.number().nullable(),
        airQualityCategory: z.string().nullable(),
        fetchedAt: z.string().nullable(),
      })
      .optional(),
    error: z.string().optional(),
  }),
  execute: async ({ userId }) => {
    try {
      const supabase = getSupabaseClient();

      const { data, error } = await supabase
        .from("environment_data")
        .select("*")
        .eq("user_id", userId)
        .order("fetched_at", { ascending: false })
        .limit(1)
        .single();

      if (error) {
        // No data is not necessarily an error
        if (error.code === "PGRST116") {
          return { hasData: false };
        }
        return { hasData: false, error: error.message };
      }

      return {
        hasData: true,
        data: {
          city: data.location_city,
          uvIndex: data.uv_index,
          weatherCondition: data.weather_condition,
          temperature: data.temperature,
          airQualityIndex: data.air_quality_index,
          airQualityCategory: data.air_quality_category,
          fetchedAt: data.fetched_at,
        },
      };
    } catch (err) {
      return {
        hasData: false,
        error:
          err instanceof Error
            ? err.message
            : "Failed to fetch environment data",
      };
    }
  },
});

/**
 * Tool to log a health note from voice or chat.
 * Health notes are free-form observations about the user's health.
 */
export const createHealthNoteTool = createTool({
  id: "create-health-note",
  description:
    "Creates a health note from user's voice or chat input. Use this when user mentions something about their health, symptoms, or wellness.",
  inputSchema: z.object({
    userId: z.string().describe("The user's unique identifier"),
    content: z.string().describe("The health note content"),
    source: z
      .enum(["voice", "chat", "manual"])
      .default("chat")
      .describe("Source of the note"),
    sourceRecordingId: z
      .string()
      .optional()
      .describe("ID of voice recording if from voice"),
    tags: z
      .array(z.string())
      .default([])
      .describe("Tags for categorizing the note"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    noteId: z.string().optional(),
    error: z.string().optional(),
  }),
  execute: async ({ userId, content, source, sourceRecordingId, tags }) => {
    try {
      const supabase = getSupabaseClient();

      const { data, error } = await supabase
        .from("health_notes")
        .insert({
          user_id: userId,
          content,
          source,
          source_recording_id: sourceRecordingId || null,
          tags: tags || [],
        })
        .select("id")
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true, noteId: data.id };
    } catch (err) {
      return {
        success: false,
        error:
          err instanceof Error ? err.message : "Failed to create health note",
      };
    }
  },
});

// Export all health tools
export const healthTools = {
  createHealthInsight: createHealthInsightTool,
  getHealthInsights: getHealthInsightsTool,
  getEnvironmentData: getEnvironmentDataTool,
  createHealthNote: createHealthNoteTool,
};

